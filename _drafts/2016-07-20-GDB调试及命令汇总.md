---
layout: post
title:  "GDB调试及命令汇总"
date:    2016-07-20 20:50
categories: Linux
comments: true
---

# 1 内容简介

下面按照 开始、断点、变量的顺序依次查看命令

# 2 GDB简介


# 3 常用命令

## 3.1 调试前准备

生成调试信息：

```
g++ main.cpp -o main -g 
g++ main.cpp -o main -g3
```
-g命令与-o命令一样，是分级的默认为g2不包含宏信息(调试宏的基本方法：macro exp SUM(3,5))

## 3.2 开始调试

在调用GDB时可以指定启动文件，如：

```
gdb <-tui> <-command=cfile> <file>
```

要在可执行文件file上运行GDB，首先要从文件cfile中读取命令。-tui表示显示源码界面调试！

```
set args arg1 arg2 设置main()参数 
show args  查看设置好的参数 
run(r) <filename> 开始运行程序
info program 来查看程序状态
```

 * 调试已运行的程序

```
gdb PID process-id 挂接正在运行的程序。
attach process-id 命令来挂接进程的PID。
detach process-id 取消挂接的进程。
```

## 3.3 断点的生命周期

### 设置断点的几种方式

 * 

```
一般断点
break(b) filename:line_number 
break(b) function（函数名）。所有重载函数均会被设置为断点

条件断点
condition 1 num_y == 1 只有当满足条件num_y == 1时，GDB才会在断点1处暂停程序的执行。
break(b) 30 if num_y == 1 用break if 条件语句可以用括号()括起来，也可以不用。

临时断点：
tbreak num 断点在首次到达该指定行后就不再有效。
```

### 查看断点

```
查看所有断点信息：
info break
info breakpoint
info b

断点命令:
commands 1  #breakpoint_number
silent
printf "命令和C中printf函数类似，只是括号是可选的"
end

```

让GDB在每次到达某个断点时自动执行一组命令，从而自动完成某一任务。使用commands命令设置命令列表：

### 禁用&删除断点

```
禁用：
disable breakpoint-list（多个用空格分隔开的多个断点标识符或者1-5）
disable （禁用所有现存断点）
enable breakpoint-list （启用断点）
enable once breakpoint-list （在下次引起GDB暂停执行后禁用：）

删除：
delete （删除所有）
delete break_point_num 

依据位置删除断点：
clear filename:funtion
clear filename:line_number
clear：清除GDB将执行的下一个指令处的断点
```

## 3.4 变量操作

```
查看变量
whatis x (查看类型)
print(p) x (查看值)
 
修改变量
set var x=4 (令x=4)
```
set var 因为set是gdb的命令，var的作用是告诉GDB，x不是GDB的参数，而是程序的变量

### 3.5 继续运行

```
单步执行：
step（s） n 进入函数执行 n可选，表示执行n行
next（n） n 不进入函数执行， n可选，表示执行n行

继续执行：
continue（c）n 直到遇到另一个断点或者程序结束。可选的数值参数n，要求跳过下面n个断点。

跳出：
finish（fin） 跳出当前的函数。
until（u）  跳出当前循环
```

### 3.6 监视点的生命周期

被监视的变量在值发生变化时，会打印变化前后的值

```
添加监视点
watch <表达式>（变量名或表达式）
deltet <变量>
info registers （监视寄存器）

查看监视点
info b
info watchpoints

删除监视点
d n(监视点编号)
```

### 3.7 自动显示的生命周期

```
添加变量
display expr
display/fmt expr
display/fmt addr
```

查看自动显示
info display

删除自动显示
undisplay nums 
delete display nums

失效自动显示
disable display dnums
enable display dnums
```
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，
当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。

### 3.8 查看源代码

```
list lineNum 在lineNum的前后源代码显示出来
list + 列出当前行的后面代码行
list - 列出当前行的前面代码行
list function
set listsize count设置显示代码的行数
show listsize 显示打印代码的行数
list first,last显示从first到last的源代码行
```

### 3.9 显示调用栈

显示栈帧之后，就可以看出程序在何处停止(即断点的位置)，以及程序的调用路径,方便理解程序架构。

backtrace(bt) == where == info stack

```
backtrace      显示所有栈帧。
backtrace N    只显示开头 N 个栈帧。
backtrace -N   只显示最后 N 个栈帧。
backtrace full 不仅显示backtrace，还有显示局部变量。

栈跳转：
up n 向栈的上面移动n层，可以不打n，表示向上移动一层。
down n 向栈的下面移动n层，可以不打n，表示向下移动一层。

当前栈层的信息：
frame 或 f 查看当前栈层的信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。
info frame
info f
```

### 3.10 函数操作

```
强制返回
return expression

使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。

强制调用
call fun
```


### 3.11 并发程序


 * 多线程

如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线程。GDB很容易帮你完成这一工作。

```
info threads (查看线程ID)
break num thread threadno
break num thread threadno if …
```
如果不指定‘thread threadno ’则表示你的断点设在所有线程上面。

 * 多进程

GDB对使用fork/vfork创建子进程的程序提供了follow-fork-mode选项来支持多进程调试。

```
set follow-fork-mode parent：fork之后继续调试父进程，子进程不受影响。
set follow-fork-mode child: fork之后调试子进程，父进程不受影响
break 子进程行号
```


### 3.12 自定义命令

自定义命令的格式为


```
define <command>
<code>
end
document <command>
<help text>
end
```
GDB可自定义宏命令来简化方便调试过程.命令定义在文件
.gdbinit文件中.

在插入较多的断点程序中，可以批量执行，不用每次启动调试都插入很多次断点

# 4 总结


# 5 参考

[GDB常用命令](http://www.cnblogs.com/me115/p/3837960.html)
